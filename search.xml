<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PDF模板</title>
      <link href="/2022/12/10/PDF%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/12/10/PDF%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="PDF模板的画法"><a href="#PDF模板的画法" class="headerlink" title="PDF模板的画法"></a>PDF模板的画法</h1><ul><li>今天的任务是画一个pdf模板，之前没有接触过这个东西，然后对照着之前的模板尝试了几次，其中遇见了很多问题<h3 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h3></li><li>一开始，并不是很清楚colspan 和 rowspan 这两个属性，以为和ionic中一样，一行就只有十二份，导致我画的表格一直对应不起来，后来了解到</li><li>colspan=”（合并列的数量）”(但是后面的内容会被挤到新的一列）</li><li>rowspan=”（合并行的数量）”（但是被占用行的内容会被挤到新的列）</li><li>就类似于我们熟悉的合并单元格，让这个单元格占几行或者占几列<h3 id="问题二："><a href="#问题二：" class="headerlink" title="问题二："></a>问题二：</h3></li><li>清楚了colspan 和 rowspan 的用法之后，慢慢的画出来一个基本的表格，<img src="/2022/12/10/PDF%E6%A8%A1%E6%9D%BF/1.png" class title="This is an test image"></li><li>然后因为其中有些行是不固定的，是根据数据量来确定的，因此就加入了循环，然后有的单元格所占有的列数也是根据数据的多少来动态变化的，因此想到<br>在传数据的时候动态的计算出数据的多少，用一个变量来表示所占列数。<br>最终效果为：<img src="/2022/12/10/PDF%E6%A8%A1%E6%9D%BF/2.png" class title="This is an test image"><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2></li><li>1.首先我们需要创建一个新的html文件建立好基本框架。</li><li>2.在body标签内输入一个table标签表示这是一个表格。</li><li>3.在table标签内建立一行tr以及表头th并输入表头内容。</li><li>4.接着再建立新的一行，并在tr标签里添加单元格td.</li><li>5.如需多行数据则只需将单元格多复制几份即可。</li><li>6.最后在table标签添加边框，一个简单的表格就完成了。</li><li>7.还可以根据实际需求将单元格合并，如果需要将多个列合并只需要在td标签内添加colspan=”（合并列的数量）”(但是后面的内容会被挤到新的一列）<br>  如果要合并多个行则只需要在td标签内添加rowspan=”（合并行的数量）”（但是被占用行的内容会被挤到新的列</li><li>8.如果觉得单元格之间的距离影响美观，还可以用cellspacing=”(数字)”来设置单元格之间的距离，输入0则是没有距离。</li><li>9.如果觉得表格边框颜色太单调想鲜艳一点，可以用bordercolor属性设置边框颜色。</li><li>10.除了上面这些样式，还可以设置表格的宽高、插入背景图片、字体颜色、文字居中等。（设置多个样式建议在style标签内进行设置）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小功能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm启动报错——端口被占用</title>
      <link href="/2022/12/01/npm%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%E2%80%94%E2%80%94%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8/"/>
      <url>/2022/12/01/npm%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%E2%80%94%E2%80%94%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="npm启动报错——端口被占用"><a href="#npm启动报错——端口被占用" class="headerlink" title="npm启动报错——端口被占用"></a>npm启动报错——端口被占用</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>npm启动端口被占用报错如下：可以看出9244端口被占用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">11月29日 18:52Port 9244 is already in use. Use &#x27;--port&#x27; to specify a different port.</span><br><span class="line">npm ERR! code ELIFECYCLE</span><br><span class="line">npm ERR! gpsoft@0.0.0 start: `ng serve --host 0.0.0.0 --port 9244 --proxy-config loca.conf.json --base-href /gpmes/ -o`</span><br><span class="line">npm ERR! Exit status 1</span><br><span class="line">npm ERR!</span><br><span class="line">npm ERR! Failed at the gpsoft@0.0.0 start script.</span><br><span class="line">npm ERR! This is probably not a problem with npm. There is likely additional logging output above.</span><br><span class="line"></span><br><span class="line">npm ERR! A complete log of this run can be found in:</span><br><span class="line">npm ERR!     C:\Users\17420\AppData\Roaming\npm-cache\_logs\2022-11-29T10_39_02_126Z-debug.log</span><br></pre></td></tr></table></figure><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3></li><li>用Windows+R键，输入cmd进入DOS窗口，输入命令：netstat -ano|findstr 9244 找到该端口号对应的PID号</li><li>用命令taskkill /pid 11464 /F 强制杀掉进程 （11464）为PID号，显示成功过后，再次运行npm start成功运行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS D:\work\Code\dnn-gp-osm-web&gt; npm start            </span><br><span class="line"></span><br><span class="line">&gt; gpsoft@0.0.0 start D:\work\Code\dnn-gp-osm-web</span><br><span class="line">&gt; ng serve --host 0.0.0.0 --port 9244 --proxy-config loca.conf.json --base-href /gpmes/ -o</span><br><span class="line"></span><br><span class="line">** Angular Live Development Server is listening on 0.0.0.0:9244, open your browser on http://localhost:9244/gpmes **</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 日常bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.两数相加</title>
      <link href="/2022/11/26/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2022/11/26/2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ul><li>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</li><li>请你将两个数相加，并以相同形式返回一个表示和的链表。</li><li>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。<h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><h4 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><h4 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4></li><li>每个链表中的节点数在范围 [1, 100] 内</li><li>0 &lt;= Node.val &lt;= 9</li><li>题目数据保证列表表示的数字不含前导零</li></ul><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><ul><li>在我认为，给了两个非空链表，然后倒序存储数字，每个节点不超过9，那么我们只需要遍历两个链表，然后初始化一个int类型的变量tag（初始值为零）来计算两个数相加超过十会进位的情况，如果链表不为空，那么数为链表中存储的数字，如果为空那么赋值为0.然后定义int类型的sum的等于两个链表的数加上tag，两年个节点一开始都为null，先判断head是否为空，如果为空那么创建一个节点使head和node都指向该节点，并且为赋值为sum%10,也就是只取和的个位数，并且给tag赋值为sum/10，也就是取了十位数。之后继续遍历直到两个链表都为空，都为空之后判断tag是否大于零，如果大于零，那么需要创建一个新的节点，并且把tag的值赋给新节点，最后返回head。</li></ul><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) &#123;</span><br><span class="line">    struct ListNode *head = NULL, *node = NULL;</span><br><span class="line">    int tag = 0;</span><br><span class="line">    while(l1 != NULL || l2 != NULL)&#123;</span><br><span class="line">        int n1 = l1 ? l1-&gt;val : 0;</span><br><span class="line">        int n2 = l2 ? l2-&gt;val : 0;</span><br><span class="line">        int sum = n1 + n2 + tag;</span><br><span class="line">        if(!head)&#123;</span><br><span class="line">            head = node = malloc(sizeof(struct ListNode));</span><br><span class="line">            node-&gt;val = sum % 10;</span><br><span class="line">            node-&gt;next = NULL;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            node-&gt;next = malloc(sizeof(struct ListNode));</span><br><span class="line">            node-&gt;next-&gt;val = sum % 10;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            node-&gt;next = NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l1)&#123;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l2)&#123;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tag = sum / 10;</span><br><span class="line">    &#125;</span><br><span class="line">    if(tag &gt; 0)&#123;</span><br><span class="line">        node-&gt;next = malloc(sizeof(struct ListNode));</span><br><span class="line">        node-&gt;next-&gt;val = tag;</span><br><span class="line">        node-&gt;next-&gt;next = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Uncaught (in promise): removeView was not found</title>
      <link href="/2022/11/24/Uncaught-in-promise-removeView-was-not-found/"/>
      <url>/2022/11/24/Uncaught-in-promise-removeView-was-not-found/</url>
      
        <content type="html"><![CDATA[<h2 id="‘Uncaught-in-promise-removeView-was-not-found’"><a href="#‘Uncaught-in-promise-removeView-was-not-found’" class="headerlink" title="‘Uncaught (in promise): removeView was not found’"></a>‘Uncaught (in promise): removeView was not found’</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ul><li>离子 - 错误:未捕获(承诺):未找到 removeView</li><li>这个问题是在退料功能时加入一个弹窗时，然后在弹窗功能结束消失的时候报了一个这样的错误。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">core.js:1449 ERROR Error: Uncaught (in promise): removeView was not found</span><br><span class="line">    at c (polyfills.js:3:19752)</span><br><span class="line">    at c (polyfills.js:3:19461)</span><br><span class="line">    at polyfills.js:3:20233</span><br><span class="line">    at t.invokeTask (polyfills.js:3:15660)</span><br><span class="line">    at Object.onInvokeTask (core.js:4751:1)</span><br><span class="line">    at t.invokeTask (polyfills.js:3:15581)</span><br><span class="line">    at r.runTask (polyfills.js:3:10834)</span><br><span class="line">    at o (polyfills.js:3:7894)</span><br></pre></td></tr></table></figure><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3></li><li>在网上搜到的原因可能是因为在调用this.loading.dismiss()时可能会关闭相同的加载两次。<img src="/2022/11/24/Uncaught-in-promise-removeView-was-not-found/1.png" class title="This is an test image"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">showRadio() &#123;</span><br><span class="line">    let alert = this.alertCtrl.create();</span><br><span class="line">    alert.setTitle(&#x27;目标仓库&#x27;);</span><br><span class="line">    for (let i = 0; i &lt; this.typeData.length; i++) &#123;</span><br><span class="line">        alert.addInput(&#123;</span><br><span class="line">            type: &quot;radio&quot;,</span><br><span class="line">            label: this.typeData[i].name,</span><br><span class="line">            value: this.typeData[i].id,</span><br><span class="line">            handler: data =&gt; &#123;</span><br><span class="line">                this.querys.cangkuid = data.value;</span><br><span class="line">                this.targetstorehouse = data.label;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    alert.addButton(&quot;取消&quot;);</span><br><span class="line">    alert.addButton(&#123;</span><br><span class="line">        text: &#x27;确认&#x27;,</span><br><span class="line">        handler: data =&gt; &#123;</span><br><span class="line">            this.confirm();</span><br><span class="line">            alert.dismiss();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    alert.present();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>然后把方法中点击确定之后alert.dismiss()这个方法去掉，然后再次运行之后问题解决。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 日常bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>对接sap导入嵌套表再嵌套表问题</title>
      <link href="/2022/11/22/%E5%AF%B9%E6%8E%A5sap%E5%AF%BC%E5%85%A5%E5%B5%8C%E5%A5%97%E8%A1%A8%E5%86%8D%E5%B5%8C%E5%A5%97%E8%A1%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2022/11/22/%E5%AF%B9%E6%8E%A5sap%E5%AF%BC%E5%85%A5%E5%B5%8C%E5%A5%97%E8%A1%A8%E5%86%8D%E5%B5%8C%E5%A5%97%E8%A1%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ul><li>在对接出库单扫码接口的时候，出现了一种新的传参方式，它是在导入中放了一个structure，然后structure中还有表结构，这种情况是第一次见，之前遇到的情况有导入中有imports，表中有表结构，或者还有导入中有imports表中也有表结构三种情况。<h3 id="导入中有imports"><a href="#导入中有imports" class="headerlink" title="导入中有imports"></a>导入中有imports</h3></li><li>这种情况就是只有在导入中有字段，我们一般处理的方式就是把它需要的字段放进map里，然后调用一个工具方法，把这些字段put进imports中<h1 id><a href="#" class="headerlink" title></a><img src="/2022/11/22/%E5%AF%B9%E6%8E%A5sap%E5%AF%BC%E5%85%A5%E5%B5%8C%E5%A5%97%E8%A1%A8%E5%86%8D%E5%B5%8C%E5%A5%97%E8%A1%A8%E9%97%AE%E9%A2%98/1.png" class title="This is an test image"></h1><h1 id="-1"><a href="#-1" class="headerlink" title></a><img src="/2022/11/22/%E5%AF%B9%E6%8E%A5sap%E5%AF%BC%E5%85%A5%E5%B5%8C%E5%A5%97%E8%A1%A8%E5%86%8D%E5%B5%8C%E5%A5%97%E8%A1%A8%E9%97%AE%E9%A2%98/2.png" class title="This is an test image"></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Object&gt; m = new HashMap&lt;&gt;();</span><br><span class="line">        m.put(&quot;ZT&quot;,&quot;state&quot;);</span><br><span class="line">        m.put(&quot;VBELN&quot;,&quot;outboundno&quot;);</span><br><span class="line">        System.out.println(&quot;更改装车状态接口&quot;);</span><br><span class="line">        String message = esbUtils.postSapByImports(&quot;ZFM_GP_SD_APP_CKDZTGX&quot;,m);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public  String postSapByImports(String functionName, Map&lt;String, Object&gt; params) &#123;</span><br><span class="line">        if (params==null) throw  new RuntimeException(&quot;传递给SAP的数据为空！&quot;);</span><br><span class="line">        BapiRFC bapiRFC = new BapiRFC(functionName);</span><br><span class="line">        BapiRFC.Imports imports = bapiRFC.getImports();</span><br><span class="line">        imports.putAll(params);</span><br><span class="line">        String response = doPost(ESBAddress, null,bapiRFC.toString());</span><br><span class="line">        System.out.println(response);</span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="导入中为空，表中有个表结构。"><a href="#导入中为空，表中有个表结构。" class="headerlink" title="导入中为空，表中有个表结构。"></a>导入中为空，表中有个表结构。</h3></li><li>这种情况就是导入中为空，然后表中有个IN_TAB这个就是入参的那个表结构，这种就是创建一个BapiRFC.Table类型的对象，然后把一个list放进table中<h1 id="-2"><a href="#-2" class="headerlink" title></a><img src="/2022/11/22/%E5%AF%B9%E6%8E%A5sap%E5%AF%BC%E5%85%A5%E5%B5%8C%E5%A5%97%E8%A1%A8%E5%86%8D%E5%B5%8C%E5%A5%97%E8%A1%A8%E9%97%AE%E9%A2%98/3.png" class title="This is an test image"></h1><h1 id="-3"><a href="#-3" class="headerlink" title></a><img src="/2022/11/22/%E5%AF%B9%E6%8E%A5sap%E5%AF%BC%E5%85%A5%E5%B5%8C%E5%A5%97%E8%A1%A8%E5%86%8D%E5%B5%8C%E5%A5%97%E8%A1%A8%E9%97%AE%E9%A2%98/4.png" class title="This is an test image"></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String interfacename=&quot;ZFM_GPBX_MES_PP_CREATERUKU&quot;;</span><br><span class="line">           String response = esbUtils.postSapByTable(interfacename, list);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public  String postSapByTable(String functionName,  List&lt;? extends Map&lt;String, ?&gt;&gt; list) &#123;</span><br><span class="line">        if (list==null) throw  new RuntimeException(&quot;传递给SAP的数据为空！&quot;);</span><br><span class="line">        BapiRFC bapiRFC = new BapiRFC(functionName);</span><br><span class="line">        BapiRFC.Table table = bapiRFC.getTable(&quot;IN_TAB&quot;);</span><br><span class="line">        table.addRows(list);</span><br><span class="line">        String response = doPost(ESBAddress, null,bapiRFC.toString());</span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="导入中有imports，表中也有表结构"><a href="#导入中有imports，表中也有表结构" class="headerlink" title="导入中有imports，表中也有表结构"></a>导入中有imports，表中也有表结构</h3></li><li>这种情况就是导入中有imports，表中也有表结构，这种处理的方式就是声明一个BapiRFC.Table和一个BapiRFC.Imports，然后把导入中的字段放进imports中把list放进table中。<h1 id="-4"><a href="#-4" class="headerlink" title></a><img src="/2022/11/22/%E5%AF%B9%E6%8E%A5sap%E5%AF%BC%E5%85%A5%E5%B5%8C%E5%A5%97%E8%A1%A8%E5%86%8D%E5%B5%8C%E5%A5%97%E8%A1%A8%E9%97%AE%E9%A2%98/5.png" class title="This is an test image"></h1><h1 id="-5"><a href="#-5" class="headerlink" title></a><img src="/2022/11/22/%E5%AF%B9%E6%8E%A5sap%E5%AF%BC%E5%85%A5%E5%B5%8C%E5%A5%97%E8%A1%A8%E5%86%8D%E5%B5%8C%E5%A5%97%E8%A1%A8%E9%97%AE%E9%A2%98/6.png" class title="This is an test image"></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public  String postSapByTablegp(String functionName,  List&lt;? extends Map&lt;String, ?&gt;&gt; list) &#123;</span><br><span class="line">       if (list==null) throw  new RuntimeException(&quot;传递给SAP的数据为空！&quot;);</span><br><span class="line">       BapiRFC bapiRFC = new BapiRFC(functionName);</span><br><span class="line">       BapiRFC.Table table = bapiRFC.getTable(&quot;IN_TAB_GP&quot;);</span><br><span class="line">       table.addRows(list);</span><br><span class="line">       BapiRFC.Imports imports =bapiRFC.getImports();</span><br><span class="line">       imports.put(&quot;BS&quot;,&quot;GP&quot;);</span><br><span class="line">       String response = doPost(ESBAddress, null,bapiRFC.toString());</span><br><span class="line">       return response;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="导入中有嵌套表"><a href="#导入中有嵌套表" class="headerlink" title="导入中有嵌套表"></a>导入中有嵌套表</h3></li><li>这种导入中有表的这种，也是需要声明一个import，然后有一个imports.getTable(“INTAB”)方法，得到一个BapiRFC.Table，然后再往表里面放值即可。<img src="/2022/11/22/%E5%AF%B9%E6%8E%A5sap%E5%AF%BC%E5%85%A5%E5%B5%8C%E5%A5%97%E8%A1%A8%E5%86%8D%E5%B5%8C%E5%A5%97%E8%A1%A8%E9%97%AE%E9%A2%98/7.png" class title="This is an test image"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BapiRFC bapiRFC = new BapiRFC(&quot;ZFM_MM_MDM_002&quot;);</span><br><span class="line">        Imports imports = bapiRFC.getImports();</span><br><span class="line">        Table intab = imports.getTable(&quot;INTAB&quot;);</span><br><span class="line">        Row row = intab.addRow();</span><br><span class="line">        row.put(&quot;LIFNR&quot;, &quot;DONGPZ&quot;)</span><br><span class="line">                .put(&quot;NAME1&quot;, &quot;XXX&quot;)</span><br><span class="line">                .put(&quot;BPEXT&quot;, &quot;XX&quot;)</span><br><span class="line">                .put(&quot;EMNFR&quot;, &quot;XXX&quot;)</span><br><span class="line">                .put(&quot;STCD5&quot;, &quot;AAAA&quot;)</span><br><span class="line">                .put(&quot;KTOKK&quot;, &quot;CCCC&quot;)</span><br><span class="line">                .put(&quot;STREET&quot;, &quot;&quot;)</span><br><span class="line">                .put(&quot;REGIO&quot;, &quot;XX&quot;)</span><br><span class="line">                .put(&quot;LAND1&quot;, &quot;&quot;)</span><br><span class="line">                .put(&quot;TELF1&quot;, &quot;XXXXXXXXXXXX&quot;)</span><br><span class="line">                .put(&quot;SMTP_ADDR&quot;, &quot;&quot;)</span><br><span class="line">                .put(&quot;CITY&quot;, &quot;&quot;);</span><br><span class="line">        Table bank = row.getTable(&quot;BANK&quot;);</span><br><span class="line">        bank.addRow().put(&quot;BANKS&quot;, &quot;AD&quot;).put(&quot;BANKL&quot;, &quot;WWW&quot;).put(&quot;BANKN&quot;, &quot;EEE&quot;);</span><br></pre></td></tr></table></figure><h3 id="只有导入中有个structure"><a href="#只有导入中有个structure" class="headerlink" title="只有导入中有个structure"></a>只有导入中有个structure</h3></li><li>今天遇到一个新的方式，然后只有在导入中有个structure，我一开始以为是表结构，然后尝试最上面三种方式都不可以，后来问了滨哥，才知道这种方式的传值也已经解决了，需要使用到imports.getTable(“INTAB”)方法，需要拉一下最新的对接sap demo那个项目，然后复制BaPiRFC.java这个文件覆盖掉我们项目中这个文件，然后就有gettable这个方法。后来试了一下还是不行，原因是图中的INTAB并不是表，而是一个structure，所以我又尝试了一下import包含结构的那种方法，后来问题解决。<img src="/2022/11/22/%E5%AF%B9%E6%8E%A5sap%E5%AF%BC%E5%85%A5%E5%B5%8C%E5%A5%97%E8%A1%A8%E5%86%8D%E5%B5%8C%E5%A5%97%E8%A1%A8%E9%97%AE%E9%A2%98/7.png" class title="This is an test image"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public  String postPushScan(String functionName, OutboundSuggestBale params, String outboundno, List&lt;Map&lt;String,Object&gt;&gt; listdata) &#123;</span><br><span class="line">    if (params==null) throw  new RuntimeException(&quot;传递给SAP的数据为空！&quot;);</span><br><span class="line">    BapiRFC bapiRFC = new BapiRFC(functionName);</span><br><span class="line">    BapiRFC.Imports imports = bapiRFC.getImports();</span><br><span class="line">    BapiRFC.Structure structure = imports.getStructure(&quot;INTAB&quot;);</span><br><span class="line">    structure.put(&quot;VBELN&quot;, outboundno)</span><br><span class="line">            .put(&quot;UECHA&quot;, params.getOutboundsummaryno())</span><br><span class="line">            .put(&quot;POSNR&quot;, params.getOutboundsummaryno())</span><br><span class="line">            .put(&quot;MATNR&quot;, params.getGcid())</span><br><span class="line">            .put(&quot;ZBAOH&quot;, params.getPackno())</span><br><span class="line">            .put(&quot;LGORT&quot;, params.getStorehouse())</span><br><span class="line">            .put(&quot;CHARG&quot;, params.getPicino())</span><br><span class="line">            .put(&quot;LFIMG&quot;, params.getQty())</span><br><span class="line">            .put(&quot;VRKME&quot;, params.getUnit());</span><br><span class="line">    BapiRFC.Table ZBHXX = structure.getTable(&quot;ZBHXX&quot;);</span><br><span class="line">    ZBHXX.addRows(listdata);</span><br><span class="line">    String response = doPost(ESBAddress, null,bapiRFC.toString());</span><br><span class="line">    System.out.println(response);</span><br><span class="line">    return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 日常bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数之和</title>
      <link href="/2022/11/21/1/"/>
      <url>/2022/11/21/1/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><ul><li>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</li><li>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</li><li><p>你可以按任意顺序返回答案。</p></li><li><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure></li><li>示例 2：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure></li><li>示例 3：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure></li></ul><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int n = nums.length;</span><br><span class="line">        for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">            for(int j = i + 1;j &lt; n; j++)&#123;</span><br><span class="line">                if(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                    return new int[]&#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return new int[0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>思路：这个方法就是遍历数组中的元素X，然后继续遍历数组中X元素之后的元素，查看有没有target-X。<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        int[] res = new int[2];</span><br><span class="line">        for (int i = 0; i &lt;nums.length; i++) &#123;</span><br><span class="line">            if (map.containsKey(target-nums[i]))&#123;</span><br><span class="line">                res[0]=i;</span><br><span class="line">                res[1]=map.get(target-nums[i]);</span><br><span class="line">                return res;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                map.put(nums[i],i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>思路：因为解决方法一时间复杂度较高，参考他们的做法，发现一种时间复杂度低的办法，就是只循环一次，先判断哈希表key中有没有target-nums[i]，如果有的话，就直接返回新数组{i，map.get(target-nums[i])}，如果没有，把数组的值作为map的key，数组下标作为value存到map中。</li></ul>]]></content>
      
      
      <categories>
          
          <category> -算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -算法 -数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构基本概念</title>
      <link href="/2022/11/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/11/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构基本概念"><a href="#数据结构基本概念" class="headerlink" title="数据结构基本概念"></a>数据结构基本概念</h1><h2 id="知识总览"><a href="#知识总览" class="headerlink" title="知识总览"></a>知识总览</h2><img src="/2022/11/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/1.png" class title="This is an test image"><h2 id="数据结构三要素"><a href="#数据结构三要素" class="headerlink" title="数据结构三要素"></a>数据结构三要素</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><ul><li>逻辑结构分为线性结构和非线性结构：<br>线性结构：线性表，栈和队列<br>非线性结构：树、图和集合<h3 id="物理结构（存储结构）"><a href="#物理结构（存储结构）" class="headerlink" title="物理结构（存储结构）"></a>物理结构（存储结构）</h3></li><li>顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</li><li>链式存储：逻辑上相邻的元素在物理位置上可以不相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。</li><li>索引存储：在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）</li><li>散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希存储。<h3 id="数据的运算"><a href="#数据的运算" class="headerlink" title="数据的运算"></a>数据的运算</h3></li><li>施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3></li><li>解题方案准确而完整的描述。<h3 id="五个特征"><a href="#五个特征" class="headerlink" title="五个特征"></a>五个特征</h3></li><li>有穷性：一个算法必须总在执行又穷步之后结束，且每一步都可在有穷时间内完成。（算法必须有穷，程序可以无穷）</li><li>确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。</li><li>可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。</li><li>输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。</li><li>输出：一个算法有零个或多个输出，这些输出是与输入有着某种特定关系的量。<h4 id="“好”算法的特质"><a href="#“好”算法的特质" class="headerlink" title="“好”算法的特质"></a>“好”算法的特质</h4><em>正确性：算法应能够正确的解决求解问题</em>可读性：算法应具有良好的可读性，以帮助人们理解。<br><em>健壮性：输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。</em>高效率与低存储量需求：省时省内存，时间复杂度、空间复杂度低<h3 id="效率的度量"><a href="#效率的度量" class="headerlink" title="效率的度量"></a>效率的度量</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4></li></ul>]]></content>
      
      
      <categories>
          
          <category> -计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乐观锁与悲观锁</title>
      <link href="/2022/11/18/%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81/"/>
      <url>/2022/11/18/%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-悲观锁"><a href="#1-悲观锁" class="headerlink" title="1.悲观锁"></a>1.悲观锁</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><ul><li><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。在Java中，synchronized从偏向锁、轻量级锁到重量级锁，全是悲观锁。JDK提供的Lock实现类全是悲观锁。</p></li><li><p>手动加悲观锁：<br>读锁：LOCK tables test_db read，释放锁：UNLOCK TABLES;<br>写锁：LOCK tables test_db WRITE，释放锁：UNLOCK TABLES;<br>读锁与写锁<br>如果要更新数据，那么加锁的时候就直接加写锁，一个线程持有写锁的时候别的线程无论读还是写都需要等待；<br>如果是读取数据仅为了前端展示，那么加锁时就明确地加一个读锁，其他线程如果也要加读锁，不需要等待，可以直接获取（读锁计数器+1）<br>虽然读写锁感觉与乐观锁有点像，但是读写锁是悲观锁策略。因为读写锁并没有在更新前判断值有没有被修改过，而是在加锁前决定应该用读锁还是写锁。</p></li><li>特点:<br>优点：可以完全保证数据的独占性和正确性，因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;<br>缺点：因为每次请求都会先对数据进行加锁， 然后进行数据操作，最后再解锁，而加锁释放锁的过程会造成消耗，所以性能不高;</li></ul><h2 id="2-乐观锁"><a href="#2-乐观锁" class="headerlink" title="2.乐观锁"></a>2.乐观锁</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><ul><li><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下，在此期间有没有别人去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS。</p></li><li><p>形象化记忆：乐观锁认为对数据的操作不会产生冲突，所以不会加锁，而是在提交更新的时候才会对数据的冲突与否进行检测。如果发现冲突，要么再重试一次，要么切换为悲观的策略。乐观并发控制要解决的是数据库并发场景下的写-写冲突，指用无锁的方式去解决。</p></li><li>特点：<br>优点：乐观锁是一种并发类型的锁，其本身并不对数据进行加锁，而是通循环重试CAS进而实现锁的功能，其不对数据进行加锁就意味着允许多个线程同时读取（因为根本没有加锁操作）数据，但是只有一个线程可以成功更新数据，并导致其他要更新数据的线程回滚重试，这种方式大大的提高了数据操作的性能，因为整个过程中并没有“加锁”和“解锁”操作，因此乐观锁策略也被称为无锁编程。</li></ul><h3 id="3-两者的比较"><a href="#3-两者的比较" class="headerlink" title="3.两者的比较"></a>3.两者的比较</h3><ul><li>1、乐观锁并未真正加锁（不是真正的锁），效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。</li><li>2、悲观锁依赖数据库锁，效率低。更新失败的概率比较低。</li><li>3、悲观锁阻塞事务，乐观锁回滚重试，它们各有优缺点，不要认为一种一定好于另一种。像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行重试，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小功能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 乐观锁，悲观锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的三种弹出框：警告框、确认框、提示框</title>
      <link href="/2022/11/16/JavaScript%E7%9A%84%E4%B8%89%E7%A7%8D%E5%BC%B9%E5%87%BA%E6%A1%86%EF%BC%9A%E8%AD%A6%E5%91%8A%E6%A1%86%E3%80%81%E7%A1%AE%E8%AE%A4%E6%A1%86%E3%80%81%E6%8F%90%E7%A4%BA%E6%A1%86/"/>
      <url>/2022/11/16/JavaScript%E7%9A%84%E4%B8%89%E7%A7%8D%E5%BC%B9%E5%87%BA%E6%A1%86%EF%BC%9A%E8%AD%A6%E5%91%8A%E6%A1%86%E3%80%81%E7%A1%AE%E8%AE%A4%E6%A1%86%E3%80%81%E6%8F%90%E7%A4%BA%E6%A1%86/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript的三种不同弹出框：警告框、确认框、提示框"><a href="#JavaScript的三种不同弹出框：警告框、确认框、提示框" class="headerlink" title="JavaScript的三种不同弹出框：警告框、确认框、提示框"></a>JavaScript的三种不同弹出框：警告框、确认框、提示框</h1><h2 id="1、警告框：window-alert"><a href="#1、警告框：window-alert" class="headerlink" title="1、警告框：window.alert()"></a>1、警告框：window.alert()</h2><p>当我们需要用户看到一些信息时，可以使用警告框，用户必须点击警告框上的【确定】按钮，才能继续操作。</p><p>函数参数为弹出框显示的内容。<br><img src="/2022/11/16/JavaScript%E7%9A%84%E4%B8%89%E7%A7%8D%E5%BC%B9%E5%87%BA%E6%A1%86%EF%BC%9A%E8%AD%A6%E5%91%8A%E6%A1%86%E3%80%81%E7%A1%AE%E8%AE%A4%E6%A1%86%E3%80%81%E6%8F%90%E7%A4%BA%E6%A1%86/1.png" class title="This is an test image"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;JavaScript的弹出框&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;input type=&quot;button&quot; value=&quot;弹出警告框&quot; onclick=&quot;popup()&quot;/&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    function popup()&#123;</span><br><span class="line">      alert(&quot;点击[确定]以继续操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h2 id="2、确认框：window-confirm"><a href="#2、确认框：window-confirm" class="headerlink" title="2、确认框：window.confirm()"></a>2、确认框：window.confirm()</h2><p>确认框可以让用户做出一个选择，以确认接下来是否进行某种行为。</p><p>函数参数为弹出框显示的内容。</p><p>点击[确定]返回true，点击[取消]返回false。<br><img src="/2022/11/16/JavaScript%E7%9A%84%E4%B8%89%E7%A7%8D%E5%BC%B9%E5%87%BA%E6%A1%86%EF%BC%9A%E8%AD%A6%E5%91%8A%E6%A1%86%E3%80%81%E7%A1%AE%E8%AE%A4%E6%A1%86%E3%80%81%E6%8F%90%E7%A4%BA%E6%A1%86/2.png" class title="This is an test image"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;JavaScript的弹出框&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var v = confirm(&quot;是否弹出确认框&quot;);</span><br><span class="line">    //点击[确定]（返回true）则弹出一个确认框</span><br><span class="line">    if(v)&#123;</span><br><span class="line">      popup();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //弹出确认框</span><br><span class="line">    function popup()&#123;</span><br><span class="line">      alert(&quot;点击[确定]以继续操作&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h2 id="3、提示框：window-prompt"><a href="#3、提示框：window-prompt" class="headerlink" title="3、提示框：window.prompt()"></a>3、提示框：window.prompt()</h2><p>提示框让用户在进行某种操作前可以输入信息。</p><p>例如跳转到其他网页前弹出一个提示框，让用户输入要跳转的网页地址。</p><p>该函数有两个形参，形参1为弹出框显示的内容，形参2为默认的输入值。</p><p>该框点击[确定]返回输入值，点击[取消]返回null。<br><img src="/2022/11/16/JavaScript%E7%9A%84%E4%B8%89%E7%A7%8D%E5%BC%B9%E5%87%BA%E6%A1%86%EF%BC%9A%E8%AD%A6%E5%91%8A%E6%A1%86%E3%80%81%E7%A1%AE%E8%AE%A4%E6%A1%86%E3%80%81%E6%8F%90%E7%A4%BA%E6%A1%86/3.png" class title="This is an test image"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class="line">&lt;title&gt;JavaScript的弹出框&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var v = prompt(&quot;输入你要跳转的网页地址&quot;,&quot;https://www.taobao.com&quot;);</span><br><span class="line">    if(v)&#123;</span><br><span class="line">      open(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br>原文链接：<a href="https://blog.csdn.net/Dawson_Ho/article/details/109522194">https://blog.csdn.net/Dawson_Ho/article/details/109522194</a></p>]]></content>
      
      
      <categories>
          
          <category> 小功能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 弹出框 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo部署报错 spawn failed</title>
      <link href="/2022/11/15/hexo%E9%83%A8%E7%BD%B2%E6%8A%A5%E9%94%99-spawn-failed/"/>
      <url>/2022/11/15/hexo%E9%83%A8%E7%BD%B2%E6%8A%A5%E9%94%99-spawn-failed/</url>
      
        <content type="html"><![CDATA[<h1 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现:"></a>问题出现:</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (D:\workplace\blog\node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (events.js:376:20)</span><br><span class="line">      at ChildProcess.cp.emit (D:\workplace\blog\node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) &#123;</span><br><span class="line">    code: 128</span><br></pre></td></tr></table></figure><h1 id="常规解决办法："><a href="#常规解决办法：" class="headerlink" title="常规解决办法："></a>常规解决办法：</h1><h2 id="解决方法一："><a href="#解决方法一：" class="headerlink" title="解决方法一："></a>解决方法一：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 第一个就是你的邮箱，第二个就是你的用户名</span><br><span class="line">git config --global user.email &quot;2673065011@qq.com&quot;</span><br><span class="line">git config --global user.name &quot;210173313&quot;</span><br></pre></td></tr></table></figure><h2 id="解决方法二："><a href="#解决方法二：" class="headerlink" title="解决方法二："></a>解决方法二：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 删除.deploy_git文件夹,输入：</span><br><span class="line">git config --global core.autocrlf false</span><br><span class="line"># 然后，依次执行：</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="解决方法三："><a href="#解决方法三：" class="headerlink" title="解决方法三："></a>解决方法三：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 打开_config.yml配置文件，修改以下内容</span><br><span class="line"></span><br><span class="line">deploy:</span><br><span class="line">type: &#x27;git&#x27;</span><br><span class="line">repo: https://github.com/yourname/yourname.github.io.git</span><br><span class="line">branch: master</span><br><span class="line"># 其中的repo修改为</span><br><span class="line">repo: git@github.com:yourname/yourname.github.io.git</span><br></pre></td></tr></table></figure><p>试了一下以上常规方法，并没有解决问题，最后的解决办法是重新创建git仓库并连接，然后成功部署。</p>]]></content>
      
      
      <categories>
          
          <category> 日常bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>微服务调用的数据库错误导致项目报错</title>
      <link href="/2022/11/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99/"/>
      <url>/2022/11/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>今天早上刚打开项目，发现不能运行，本来以为是数据库的问题，但是后来王洁伟重启数据库服务并没有解决问题，然后直接走接口查询数据的也会报相同的错误，后来通过求助穆老师得知，是因为我们代码里的某一个微服务调用的数据库报错，然后导致项目报错。第一次遇见这种问题，在这记录一下。<br><img src="/2022/11/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%99%E8%AF%AF%E5%AF%BC%E8%87%B4%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99/1.png" class title="This is an test image"><br>192.168.0.99这个ip下的2036端口号出现了问题。解决办法目前还理解不了，希望随着知识的积累以后可以明白。</p>]]></content>
      
      
      <categories>
          
          <category> 日常bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unable to resolve path [Excipients.qty], unexpected token [Excipients]的问题</title>
      <link href="/2022/11/11/Unable-to-resolve-path-Excipients-qty-unexpected-token-Excipients-%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/11/11/Unable-to-resolve-path-Excipients-qty-unexpected-token-Excipients-%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>后台报错上面报的是无法创建类的bean的错误，一开始以为问题出现在这，然后搜到的解决办法有两种,后来试了一下都不行<br><img src="/2022/11/11/Unable-to-resolve-path-Excipients-qty-unexpected-token-Excipients-%E7%9A%84%E9%97%AE%E9%A2%98/1.png" class title="This is an test image"><br><img src="/2022/11/11/Unable-to-resolve-path-Excipients-qty-unexpected-token-Excipients-%E7%9A%84%E9%97%AE%E9%A2%98/2.png" class title="This is an test image"><br>然后后面报的错误是，Unable to resolve path [Excipients.qty], unexpected token [Excipients]，然后搜了一下，可能是因为没有在sql语句中起别名的原因，<br>后来起了个别名，然后就可以正常运行了。<br><img src="/2022/11/11/Unable-to-resolve-path-Excipients-qty-unexpected-token-Excipients-%E7%9A%84%E9%97%AE%E9%A2%98/3.png" class title="This is an test image"><br><img src="/2022/11/11/Unable-to-resolve-path-Excipients-qty-unexpected-token-Excipients-%E7%9A%84%E9%97%AE%E9%A2%98/4.png" class title="This is an test image"></p>]]></content>
      
      
      <categories>
          
          <category> 日常bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解决 TypeError: Cannot read properties of undefined (reading ‘xxx‘) </title>
      <link href="/2022/11/10/%E8%A7%A3%E5%86%B3-TypeError-Cannot-read-properties-of-undefined-reading-%E2%80%98xxx%E2%80%98/"/>
      <url>/2022/11/10/%E8%A7%A3%E5%86%B3-TypeError-Cannot-read-properties-of-undefined-reading-%E2%80%98xxx%E2%80%98/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述：Cannot-read-properties-of-undefined-reading-‘xxx’"><a href="#问题描述：Cannot-read-properties-of-undefined-reading-‘xxx’" class="headerlink" title="问题描述：Cannot read properties of undefined (reading ‘xxx’)"></a>问题描述：Cannot read properties of undefined (reading ‘xxx’)</h1><h1 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h1><ul><li><p>情况一：<br>出现该错误的原因是因为你花括号中的某些属性未定义。很有可能是因为你写错了属性名称</p></li><li><p>情况二：<br>异步请求获取数据时，由于数据时异步获取的，所以一开始是没有该数据属性，这种情况下也会报这种错误。比如说我这里有一个数据detaildata，初始值为一个空对象。是不会报错的，但是，这样就会报错了。这是为什么呢？<br>因为，detaildata.info已经是一个undefined了，你undefined.name就肯定会报错了。<br>所以在初始化时，info属性赋值为空对象就行了。</p><img src="/2022/11/10/%E8%A7%A3%E5%86%B3-TypeError-Cannot-read-properties-of-undefined-reading-%E2%80%98xxx%E2%80%98/1.png" class title="This is an test image"><p>只需要把summarydata声明为一个空对象即可。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 日常bug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>无法生成同名文件夹存储照片问题</title>
      <link href="/2022/11/10/%E6%97%A0%E6%B3%95%E7%94%9F%E6%88%90%E5%90%8C%E5%90%8D%E6%96%87%E4%BB%B6%E5%A4%B9%E5%AD%98%E5%82%A8%E7%85%A7%E7%89%87%E9%97%AE%E9%A2%98/"/>
      <url>/2022/11/10/%E6%97%A0%E6%B3%95%E7%94%9F%E6%88%90%E5%90%8C%E5%90%8D%E6%96%87%E4%BB%B6%E5%A4%B9%E5%AD%98%E5%82%A8%E7%85%A7%E7%89%87%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ul><li>一开始使用hexo new post “文件名”创建文章时，只能创建出.md文件，并不能创建出同名文件夹来存储图片<img src="/2022/11/10/%E6%97%A0%E6%B3%95%E7%94%9F%E6%88%90%E5%90%8C%E5%90%8D%E6%96%87%E4%BB%B6%E5%A4%B9%E5%AD%98%E5%82%A8%E7%85%A7%E7%89%87%E9%97%AE%E9%A2%98/1.png" class title="This is an test image">后来找到这个方法，手动创建文件夹，但是图片还是无法显示，最后找到解决办法成功解决</li><li><ol><li>在根目录下配置文件_config.yml 中有 post_asset_folder:false改为true。这样在建立文件时，Hexo会自动建立一个与文章同名的文件夹，这样就可以把与该文章相关的所有资源（图片）都放到那个文件夹里方便后面引用。如这里我放了一张test.jpg的图片。</li></ol></li><li><ol><li>git bash安装插件：npm install <a href="https://github.com/7ym0n/hexo-asset-image">https://github.com/7ym0n/hexo-asset-image</a> —save（这是个修改过的插件，经测试无问题），使用这个插件来引入图片，而不是网上那些方法里说的用传统md语法相对路径的方法。</li></ol></li><li><ol><li>插入图片时用这种方式：其中test.jpg就是你要引用的图片，我这里就是test.jpg，后面的This is an test image是图片描述，可以自己修改。</li></ol></li><li><ol><li>这样就能成功显示了，测试下吧：hexo cl &amp;&amp; hexo g &amp;&amp; hexo d</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 日常bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建Myblog中的错误</title>
      <link href="/2022/11/08/%E5%88%9B%E5%BB%BAMyblog%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF/"/>
      <url>/2022/11/08/%E5%88%9B%E5%BB%BAMyblog%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<p>在创建我的博客时，一开始遇见的错误是推送不上去，再git bash here 中输入hexo d 时会一直卡在那里没有反应，后来在配置文件中把http的地址修改为<br>ssh的地址就可以了，然后可以推送给上去但是不知道为啥一直打不开页面，后来才知道是因为创建仓库时，名字后面没有加.github.io 后缀。</p>]]></content>
      
      
      <categories>
          
          <category> 日常bug </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
